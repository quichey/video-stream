from collections import defaultdict, deque


def get_all_table_dependencies(base):
    """
    Analyzes the SQLAlchemy metadata (Base) to build a complete dependency graph
    based on Foreign Key constraints.

    Args:
        base: The SQLAlchemy Declarative Base class (or its equivalent metadata source).

    Returns:
        tuple: (all_table_names_set, dependencies_dict)
               all_table_names_set: A set of all table names defined in the metadata.
               dependencies_dict: A dictionary mapping ParentTable -> {ChildTable1, ChildTable2...}
    """
    metadata = base.metadata

    # 1. Get all table names defined in the current scope
    all_table_names = set(metadata.tables.keys())

    # 2. Initialize graph data structures
    # Dependencies maps: ParentTable -> {Children that depend on Parent}
    dependencies = defaultdict(set)

    # 3. Iterate through all tables to find foreign keys (FKs)
    for table in metadata.tables.values():
        table_name = table.name

        # Iterate through the table's foreign keys
        for fk in table.foreign_keys:
            # The parent table (referenced table) is the target of the FK.
            # FIX: Use fk.column.table.name to reliably access the referenced table name.
            parent_table_name = fk.column.table.name

            # Only track dependencies where the parent table is also within our
            # current set of tables to be processed (i.e., skip external DB links).
            if parent_table_name in all_table_names:
                # The current table (table_name) DEPENDS ON the parent_table_name
                # We store this relationship: Parent -> [Child1, Child2, ...]
                dependencies[parent_table_name].add(table_name)

    return all_table_names, dependencies


def topological_sort_tables(all_table_names, dependencies):
    """
    Performs a topological sort (Kahn's algorithm) to determine the correct
    order for seeding tables, ensuring dependencies are loaded first.

    Args:
        all_table_names (set): A set of all table names in the seeding scope.
        dependencies (defaultdict): Parent -> {Children} map generated by get_all_table_dependencies.

    Returns:
        list: The sorted list of table names.
    """
    # 1. Calculate in-degrees (number of dependencies each table has)
    in_degree = {table_name: 0 for table_name in all_table_names}

    # Iterate through all dependency relationships
    for parent in dependencies:
        for child in dependencies[parent]:
            # If the child table is in our current scope, increment its in-degree
            if child in in_degree:
                in_degree[child] += 1

    # 2. Initialize queue with tables having an in-degree of 0 (no dependencies)
    queue = deque(
        [table_name for table_name, degree in in_degree.items() if degree == 0]
    )
    sorted_list = []

    # 3. Process the queue
    while queue:
        parent = queue.popleft()
        sorted_list.append(parent)

        # Iterate over all tables that depend on the current parent
        for child in dependencies.get(parent, set()):
            if child in in_degree:
                in_degree[child] -= 1
                # If a child's in-degree drops to 0, it has no more unresolved dependencies
                if in_degree[child] == 0:
                    queue.append(child)

    # 4. Check for cycles
    if len(sorted_list) != len(all_table_names):
        # A cycle means tables reference each other (e.g., A -> B and B -> A),
        # which prevents a linear sort for seeding.
        raise RuntimeError(
            "Circular dependency detected in database schema, cannot perform topological sort."
        )

    return sorted_list


def do_whole_thing(base, requested_table_names):
    """
    Main function that executes the full dependency extraction and topological sort,
    then filters the result to include only the tables requested for seeding.

    Args:
        base: The SQLAlchemy Declarative Base class.
        requested_table_names (list): The list of table names requested to be seeded.

    Returns:
        list: The topologically sorted list containing ONLY the requested table names.
    """
    # 1. Get ALL tables and their dependencies from the SQLAlchemy metadata
    all_metadata_table_names, dependencies = get_all_table_dependencies(base)

    # 2. Perform the full topological sort on ALL tables found in the metadata
    full_sorted_list = topological_sort_tables(all_metadata_table_names, dependencies)

    # 3. Filter the sorted list to include only the requested tables
    requested_set = set(requested_table_names)
    filtered_sorted_list = [name for name in full_sorted_list if name in requested_set]

    return filtered_sorted_list
